"""
VEIL Layer 7: Ledger Verification Tests
Verifies:
- Ledger file creation.
- Request logging.
- Crypto-Chaining (PrevHash Linkage).
- Ed25519 Signatures (Integrity).
"""
import pytest
import requests
import json
import uuid
import time
import os
import shutil

ENGINE_URL = os.getenv("ENGINE_URL", "http://localhost:8000")
LEDGER_FILE = "veil.ledger.jsonl"
INTERNAL_TOKEN = "dev-secret-token-CHANGE-IN-PROD"

class TestL7Ledger:
    @classmethod
    def setup_class(cls):
        # Ensure clean state or backup
        if os.path.exists(LEDGER_FILE):
             shutil.copy(LEDGER_FILE, f"{LEDGER_FILE}.bak")

    def test_ledger_records_requests(self):
        """Send a request and verify it appears in the ledger."""
        unique_path = f"/v1/assess?trace={uuid.uuid4()}"
        headers = {
            "X-Internal-Token": INTERNAL_TOKEN,
            "Content-Type": "application/json",
             # No intent needed for health check or bypass if L7 logs everything
        }
        # Using L1 bypass for simplicity or valid token
        payload = {"method": "GET", "url": "http://test.com", "host": "test.com", "headers": {}}
        
        # We need a request that passes L1 at least to reach L7 response? 
        # L7 wraps everything. Even 403s should be logged if generated by inner layers.
        # But L1 is inner. L7 is outermost.
        # Check: app.add_middleware(L7) -> app.add_middleware(L1). 
        # Middleware stack executes in REVERSE order of addition for Request (L7 -> L1), and Forward order for Response (L1 -> L7).
        # Actually Starlette: Last added is First execution on Request.
        # My main.py: L7 added LAST (top of file logic, but bottom of stack additions?).
        # `app.add_middleware` adds to the *signature*, wrapping the previous app.
        # So last `add_middleware` call is the OUTERMOST layer.
        # I added L7 *last* (lines 23+). Wait.
        # main.py:
        # app.add_middleware(L7)
        # app.add_middleware(L4)
        # app.add_middleware(L3)
        # ...
        # If I call add_middleware(L7), then L7 wraps (L4 wraps (L3...)).
        # So L7 sees request first, then L4...
        # So L7 sees response last. 
        # Yes.
        
        # Valid intent to ensure clean flow
        intent = {
            "goal": "ledger_test",
            "action": "POST /v1/assess",
            "justification": "ledger check",
            "risk_level": "low",
            "nonce": str(uuid.uuid4()),
            "timestamp": int(time.time())
        }
        headers["X-Veil-Intent"] = json.dumps(intent)

        response = requests.post(f"{ENGINE_URL}/v1/assess", json=payload, headers=headers, timeout=5)
        
        # Wait for background task
        time.sleep(1)
        
        # Read Ledger
        with open(LEDGER_FILE, "r") as f:
            lines = f.readlines()
        
        assert len(lines) > 0
        last_entry = json.loads(lines[-1])
        
        # Verify Context
        # data inside ledger entry
        data = last_entry["data"]
        assert data["status_code"] == response.status_code
        # assert data["path"] == "/v1/assess" # Query params might change it, check partial
        
    def test_chain_integrity(self):
        """Verify hash chaining (Entry N links to N-1)."""
        with open(LEDGER_FILE, "r") as f:
            lines = f.readlines()
            
        if len(lines) < 2:
            pytest.skip("Not enough entries for chain test")
            
        import hashlib
        
        for i in range(1, len(lines)):
            prev_entry = json.loads(lines[i-1])
            curr_entry = json.loads(lines[i])
            
            # Re-calculate hash of prev_entry
            encoded = json.dumps(prev_entry, sort_keys=True).encode()
            expected_prev_hash = hashlib.sha256(encoded).hexdigest()
            
            assert curr_entry["prev_hash"] == expected_prev_hash, f"Broken Chain at line {i+1}!"

    def test_signature_verification_demo(self):
        """Proof of concept: Signatures exist and are non-empty."""
        with open(LEDGER_FILE, "r") as f:
            lines = f.readlines()
            
        last_entry = json.loads(lines[-1])
        assert "signature" in last_entry
        assert len(last_entry["signature"]) > 10 # Base64 string
